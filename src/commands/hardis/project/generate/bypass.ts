import {
  requiredOrgFlagWithDeprecations,
  SfCommand,
} from "@salesforce/sf-plugins-core";
import { Flags } from "@salesforce/sf-plugins-core";
import { Connection, SfError, Messages } from "@salesforce/core";
import { AnyJson } from "@salesforce/ts-types";
import {
  soqlQuery,
  soqlQueryTooling,
} from "../../../../common/utils/apiUtils.js";
import { execCommand, uxLog } from "../../../../common/utils/index.js";
import { prompts } from "../../../../common/utils/prompts.js";
import c from "chalk";
import path from "path";
import fs from "fs";

Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages("sfdx-hardis", "org");

import {
  parseXmlFile,
  writeXmlFile,
} from "../../../../common/utils/xmlUtils.js";

// Constants
const ALLOWED_AUTOMATIONS = ["Flow", "Trigger", "VR"];
const CREDITS_TEXT: string =
  "Generated by sfdx-hardis : https://sfdx-hardis.cloudity.com/hardis/project/generate/bypass/";
const STATUS = {
  ADDED: "added",
  SKIPPED: "skipped",
  IGNORED: "ignored",
  FAILED: "failed",
};

export default class HardisProjectGenerateBypass extends SfCommand<any> {
  public static flags: any = {
    "target-org": requiredOrgFlagWithDeprecations,
    sObjects: Flags.string({
      char: "s",
      description:
        "Comma-separated list of sObjects to bypass (e.g., Account,Contact,Opportunity). If omitted, you will be prompted to select.",
      required: false,
    }),
    automations: Flags.string({
      char: "a",
      description: `Comma-separated automations to bypass: ${ALLOWED_AUTOMATIONS.join(
        ", "
      )}`,
      required: false,
    }),
    websocket: Flags.string({
      description: messages.getMessage("websocket"),
    }),
    skipauth: Flags.boolean({
      description:
        "Skip authentication check when a default username is required",
    }),
    skipCredits: Flags.boolean({
      aliases: ["skip-credits"],
      char: "k",
      description: 'Omit the "Generated by" line in the XML files',
      required: false,
      default: false,
    }),
    applyToVrs: Flags.boolean({
      aliases: ["apply-to-vrs"],
      description: "Apply bypass to Validation Rules",
      required: false,
      default: false,
    }),
    applyToTriggers: Flags.boolean({
      aliases: ["apply-to-triggers"],
      description: "Apply bypass to Triggers",
      required: false,
      default: false,
    }),
  };

  public static description = `
    Generates bypass custom permissions and permission sets for specified sObjects and automations (Flows, Triggers, and Validation Rules). If no parameters are provided, it prompts for user selection.
  `;

  public static examples = [
    "$ sf hardis:project:generate:bypass",
    "$ sf hardis:project:generate:bypass --global",
    "$ sf hardis:project:generate:bypass --sObjects Account,Contact,Opportunity",
    "$ sf hardis:project:generate:bypass --automations Flow,Trigger,VR",
    "$ sf hardis:project:generate:bypass --sObjects Account,Opportunity --automations Flow,Trigger",
    "$ sf hardis:project:generate:bypass --skipCredits",
  ];

  // Query methods
  public async querySObjects(connection: Connection) {
    const sObjectsQuery = `
    Select Id, Label, DeveloperName, QualifiedApiName, DurableId, IsTriggerable, IsCustomizable, IsApexTriggerable 
      FROM EntityDefinition WHERE IsTriggerable = true AND IsCustomizable = true and IsCustomSetting = false ORDER BY DeveloperName`;
    const results = await soqlQuery(sObjectsQuery, connection);
    uxLog(this, `Found ${results.records.length} sObjects.`);
    return results;
  }

  public async getFilteredSObjects(
    connection: Connection
  ): Promise<{ [key: string]: string }> {
    const sObjectResults = await this.querySObjects(connection);
    const sObjectsDict: { [key: string]: string } = {};

    sObjectResults.records.forEach((record) => {
      if (
        !record.DeveloperName.endsWith("__Share") &&
        !record.DeveloperName.endsWith("__ChangeEvent")
      ) {
        sObjectsDict[
          record.DeveloperName
        ] = `${record.Label} (${record.QualifiedApiName})`;
      }
    });

    return sObjectsDict;
  }

  public async queryTriggers(connection: Connection) {
    const query = `SELECT Id, Name, Status, IsValid, Body, BodyCrc, TableEnumOrId From ApexTrigger`;
    const results = await soqlQueryTooling(query, connection);
    uxLog(this, `Found ${results.records.length} Triggers.`);
    return results;
  }

  public filterTriggerResults(triggerResults, sObjects) {
    return triggerResults.records.filter((trigger) => {
      const sObjectApiNameWithoutC = trigger.TableEnumOrId?.replace("__c", "");
      return (
        sObjectApiNameWithoutC &&
        Object.keys(sObjects).includes(sObjectApiNameWithoutC)
      );
    });
  }

  public async queryValidationRules(
    connection: Connection,
    sObjects: { [key: string]: string }
  ) {
    const query = `SELECT ValidationName, EntityDefinition.QualifiedApiName FROM ValidationRule 
      WHERE EntityDefinition.DeveloperName IN (${Object.keys(sObjects)
        .map((s) => `'${s}'`)
        .join(", ")})`;
    const results = await soqlQueryTooling(query, connection);
    uxLog(this, `Found ${results.records.length} Validation Rules.`);
    return results;
  }

  // XML Generation
  public generateXML(
    type: "customPermission" | "permissionSet",
    sObject: string,
    automation: string,
    skipCredits: boolean = false
  ): string {
    const creditsText = skipCredits ? "" : ` ${CREDITS_TEXT}`;

    if (type === "customPermission") {
      return `<?xml version="1.0" encoding="UTF-8"?>
  <CustomPermission xmlns="http://soap.sforce.com/2006/04/metadata">
    <isLicensed>false</isLicensed>
    <label>Bypass ${automation}s for ${sObject}</label>
    <description>If assigned (through a Permission Set), this Custom Permission will disable the execution of ${automation}s defined on ${sObject} object.${creditsText}</description>
  </CustomPermission>`;
    } else {
      return `<?xml version="1.0" encoding="UTF-8"?>
  <PermissionSet xmlns="http://soap.sforce.com/2006/04/metadata">
    <customPermissions>
        <enabled>true</enabled>
        <name>Bypass${sObject}${automation}s</name>
    </customPermissions>
    <hasActivationRequired>false</hasActivationRequired>
    <label>Bypass ${automation}s for ${sObject}</label>
    <description>If assigned, this Permission Set will disable the execution of ${automation}s defined on ${sObject} object.${creditsText}</description>
  </PermissionSet>`;
    }
  }

  private generateXMLFiles(
    sObject: string,
    automation: string,
    skipCredits: boolean
  ) {
    const customPermissionFile = path.join(
      `force-app/main/default/customPermissions/Bypass${sObject}${automation}s.customPermission-meta.xml`
    );
    const permissionSetFile = path.join(
      `force-app/main/default/permissionsets/Bypass${sObject}${automation}s.permissionset-meta.xml`
    );

    fs.writeFileSync(
      customPermissionFile,
      this.generateXML("customPermission", sObject, automation, skipCredits),
      "utf-8"
    );
    fs.writeFileSync(
      permissionSetFile,
      this.generateXML("permissionSet", sObject, automation, skipCredits),
      "utf-8"
    );

    uxLog(
      this,
      `Created: ${path.basename(customPermissionFile)} for ${sObject}`
    );
    uxLog(this, `Created: ${path.basename(permissionSetFile)} for ${sObject}`);
  }

  generateFiles(
    targetSObjects: { [key: string]: string },
    targetAutomations: string[],
    skipCredits: boolean
  ): void {
    Object.keys(targetSObjects).forEach((developerName) => {
      targetAutomations.forEach((automation) => {
        this.generateXMLFiles(developerName, automation, skipCredits);
      });
    });
  }

  // Metadata handling
  public async retrieveMetadataFiles(
    records: any[],
    metadataType: "ValidationRule" | "ApexTrigger"
  ): Promise<any[]> {
    const recordsChunks = this.chunkArray(records);
    const commandPromises = recordsChunks.map(async (chunk) => {
      let command = `sf project retrieve start --metadata`;
      command += chunk
        .map((record: any) => {
          return metadataType === "ValidationRule"
            ? ` ValidationRule:${record.EntityDefinition.QualifiedApiName}.${record.ValidationName}`
            : ` ApexTrigger:${record.Name}`;
        })
        .join(" ");

      return execCommand(`${command} --ignore-conflicts --json`, this, {
        debug: false,
        retry: {
          retryDelay: 30,
          retryStringConstraint: "exitCode",
          retryMaxAttempts: 3,
        },
      });
    });

    return Promise.all(commandPromises);
  }

  public chunkArray<T>(array: T[], chunkSize: number = 25): T[][] {
    return Array.from({ length: Math.ceil(array.length / chunkSize) }, (_, i) =>
      array.slice(i * chunkSize, (i + 1) * chunkSize)
    );
  }

  // Validation Rules
  public async handleValidationRuleFile(file: any, skipCredits: boolean) {
    const filePath: string = file.filePath;
    const [sObject, name] = file.fullName.split(".") as [string, string];

    try {
      const fileContent = await parseXmlFile(filePath);
      const validationRuleContent =
        fileContent.ValidationRule.errorConditionFormula[0];
      const bypassPermissionName = `$Permission.Bypass${sObject}VRs`;

      if (validationRuleContent.includes(bypassPermissionName)) {
        return {
          sObject,
          name,
          action: STATUS.IGNORED,
          comment: "SFDX-Hardis Bypass already implemented",
        };
      }

      if (/bypass/i.test(validationRuleContent)) {
        return {
          sObject,
          name,
          action: STATUS.SKIPPED,
          comment: "Another bypass mechanism exists",
        };
      }

      const creditsText = skipCredits
        ? ""
        : `/* ${CREDITS_TEXT} */
      `;
      fileContent.ValidationRule.errorConditionFormula[0] = `${creditsText} AND( NOT(${bypassPermissionName}), ${validationRuleContent})`;
      await writeXmlFile(filePath, fileContent);
      return {
        sObject,
        name,
        action: STATUS.ADDED,
        comment: "SFDX-Hardis Bypass implemented",
      };
    } catch (error) {
      return {
        sObject,
        name,
        action: STATUS.FAILED,
        comment: "Error processing file",
      };
    }
  }

  public async applyBypassToValidationRules(
    connection: Connection,
    sObjects: { [key: string]: string },
    skipCredits: boolean
  ): Promise<void> {
    const validationRuleRecords = await this.queryValidationRules(
      connection,
      sObjects
    );
    if (validationRuleRecords.records.length === 0) {
      uxLog(this, "No validation rules found for the specified sObjects.");
      return;
    }

    uxLog(
      this,
      `Processing ${validationRuleRecords.records.length} Validation Rules.`
    );
    const retrievedValidationRules = await this.retrieveMetadataFiles(
      validationRuleRecords.records,
      "ValidationRule"
    );

    const validationRulesTableReport: any = [];
    for (const metadataFile of retrievedValidationRules[0].result.files) {
      if (metadataFile.type !== "ValidationRule") continue;
      validationRulesTableReport.push(
        await this.handleValidationRuleFile(metadataFile, skipCredits)
      );
    }

    console.table(validationRulesTableReport);
  }

  // Triggers
  public async handleTriggerFile(
    file,
    skipCredits: boolean
  ): Promise<{ [key: string]: string | null }> {
    const filePath = file.filePath;
    const name = file.fullName;

    try {
      const fileContent = fs.readFileSync(filePath, "utf-8");
      const match = fileContent.match(
        /trigger\s+\w+\s+on\s+(\w+)\s*\([^)]*\)\s*{\s*/i
      );
      if (!match) {
        return {
          sObject: null,
          name,
          action: STATUS.FAILED,
          comment: "Unable to detect sObject",
        };
      }

      const sObject = match[1].replace(/__c$/, "");
      const bypassCheckLine = `if(FeatureManagement.checkPermission('Bypass${sObject}Triggers')) { return; }`;

      if (fileContent.includes(bypassCheckLine)) {
        return {
          sObject,
          name,
          action: STATUS.IGNORED,
          comment: "Bypass already implemented",
        };
      }

      if (/bypass/i.test(fileContent)) {
        return {
          sObject,
          name,
          action: STATUS.SKIPPED,
          comment: "Another bypass exists",
        };
      }

      const fullBypassLine = `${bypassCheckLine}${
        skipCredits ? "" : "//" + CREDITS_TEXT
      }`;
      const openBraceIndex = fileContent.indexOf("{");
      const beforeBrace = fileContent.substring(0, openBraceIndex + 1);
      const afterBrace = fileContent.substring(openBraceIndex + 1).trimStart();

      fs.writeFileSync(
        filePath,
        `${beforeBrace}\n\t${fullBypassLine}\n${afterBrace}`,
        "utf-8"
      );
      return {
        sObject,
        name,
        action: STATUS.ADDED,
        comment: "Bypass implemented",
      };
    } catch (error) {
      return {
        sObject: null,
        name,
        action: STATUS.FAILED,
        comment: "Error processing file",
      };
    }
  }

  public async applyBypassToTriggers(
    connection: Connection,
    sObjects: { [key: string]: string },
    skipCredits: boolean
  ): Promise<void> {
    const triggerResults = await this.queryTriggers(connection);
    const filteredTriggersResults = this.filterTriggerResults(
      triggerResults,
      sObjects
    );

    if (filteredTriggersResults.length === 0) {
      uxLog(this, "No triggers found for the specified sObjects.");
      return;
    }

    const retrievedTriggers = await this.retrieveMetadataFiles(
      filteredTriggersResults,
      "ApexTrigger"
    );
    const triggerReport: any = [];

    for (const metadataFile of retrievedTriggers[0].result.files) {
      if (
        metadataFile.type !== "ApexTrigger" ||
        !metadataFile.filePath.endsWith(".trigger")
      )
        continue;
      triggerReport.push(
        await this.handleTriggerFile(metadataFile, skipCredits)
      );
    }

    console.table(triggerReport);
  }

  // Main run method
  public async run(): Promise<AnyJson> {
    const { flags } = await this.parse(HardisProjectGenerateBypass);
    const connection = flags["target-org"].getConnection();
    const { skipCredits } = flags;
    let { applyToTriggers, applyToVrs } = flags;

    const availableSObjects = await this.getFilteredSObjects(connection);
    let targetSObjects = {};
    let targetAutomations = [];

    // Process flag inputs
    if (flags.sObjects) {
      const sObjectsFromFlag = flags.sObjects.split(",").map((s) => s.trim());
      targetSObjects = Object.fromEntries(
        Object.entries(availableSObjects).filter(([key]) =>
          sObjectsFromFlag.includes(key)
        )
      );
    }

    if (flags.automations) {
      targetAutomations = flags.automations
        .split(",")
        .map((s) => s.trim())
        .filter((s) => ALLOWED_AUTOMATIONS.includes(s));
    }

    // Generate global bypasses
    this.generateFiles({ All: "All" }, ALLOWED_AUTOMATIONS, skipCredits);

    // Handle prompts if needed
    const promptsNeeded: any = [];
    if (!Object.keys(targetSObjects).length) {
      promptsNeeded.push({
        type: "multiselect",
        name: "sobjects",
        message: "Select sObjects for bypass",
        choices: Object.entries(availableSObjects).map(([devName, label]) => ({
          title: label,
          value: devName,
        })),
      });
    }

    if (!targetAutomations.length) {
      promptsNeeded.push({
        type: "multiselect",
        name: "automations",
        message: "Select automations to bypass",
        choices: ALLOWED_AUTOMATIONS.map((a) => ({ title: a, value: a })),
      });
    }

    if (!flags.applyToVrs && !flags.applyToTriggers) {
      promptsNeeded.push({
        type: "multiselect",
        name: "applyTo",
        message:
          "To which automations do you want to automatically apply the bypass?",
        choices: [
          { title: "Validation Rules", value: "applyToVrs" },
          { title: "Triggers", value: "applyToTriggers" },
        ],
      });
    }

    if (promptsNeeded.length) {
      const promptResults = await prompts(promptsNeeded);
      if (promptResults.sobjects) {
        targetSObjects = Object.fromEntries(
          Object.entries(availableSObjects).filter(([key]) =>
            promptResults.sobjects.includes(key)
          )
        );
      }
      if (promptResults.automations) {
        targetAutomations = promptResults.automations;
      }

      if (!applyToTriggers) {
        applyToTriggers = promptResults.applyTo?.includes("applyToTriggers");
      }
      if (!applyToVrs) {
        applyToVrs = promptResults.applyTo?.includes("applyToVrs");
      }
    }

    // Validate selections
    if (!Object.keys(targetSObjects).length) {
      throw new SfError(c.red("ERROR: You must select at least one sObject."));
    }
    if (!targetAutomations.length) {
      throw new SfError(
        c.red("ERROR: You must select at least one automation type.")
      );
    }

    // Generate files and apply bypasses
    this.generateFiles(targetSObjects, targetAutomations, skipCredits);

    if (applyToVrs) {
      await this.applyBypassToValidationRules(
        connection,
        targetSObjects,
        skipCredits
      );
    }

    if (applyToTriggers) {
      await this.applyBypassToTriggers(connection, targetSObjects, skipCredits);
    }

    return {
      outputString: "Generated bypass custom permissions and permission sets",
    };
  }
}
