import { requiredOrgFlagWithDeprecations, SfCommand } from '@salesforce/sf-plugins-core';
import { Flags } from '@salesforce/sf-plugins-core';
import { Connection, SfError, Messages  } from '@salesforce/core';
import { AnyJson } from '@salesforce/ts-types';
import { soqlQuery } from '../../../../common/utils/apiUtils.js';
import { uxLog } from '../../../../common/utils/index.js';
import { prompts } from '../../../../common/utils/prompts.js';
import c from 'chalk'
import path from 'path';
import fs from 'fs';


Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('sfdx-hardis', 'org');

const ALLOWED_AUTOMATIONS = ['Flow', 'Trigger', 'VR'];
const CREDITS_TEXT: string = 'Generated by sfdx-hardis : https://sfdx-hardis.cloudity.com/hardis/project/generate/bypass/';

export default class HardisProjectGenerateBypass extends SfCommand<any> {

  public static flags: any = {
    'target-org': requiredOrgFlagWithDeprecations,
    'sObjects': Flags.string({
      char: 's',
      description: 'Comma-separated list of sObjects to bypass (e.g., Account,Contact,Opportunity). If omitted, you will be prompted to select.',
      required: false,
    }),
    'automations': Flags.string({
      char: 'a', 
      description: `Comma-separated list of automations to bypass. Allowed values: ${ALLOWED_AUTOMATIONS.join(', ')}`,
      required: false,
    }),
    'global': Flags.boolean({
      char: 'g', 
      description: 'Generate global bypasses for all automations (Flow, Trigger, VR) without selecting sObjects.',
      required: false,
      default: false
    }),
    websocket: Flags.string({
      description: messages.getMessage('websocket'),
    }),
    skipauth: Flags.boolean({
      description: 'Skip authentication check when a default username is required',
    }),
    'skipCredits': Flags.boolean({
      aliases: ['skip-credits'],
      char: 'k',
      description: 'If true, omit the "Generated by" line in the XML files.',
      required: false,
      default: false
    }),
  };


  public static description = `
    Generates bypass custom permissions and permission sets for specified sObjects and automations (Flows, Triggers, and Validation Rules). If no parameters are provided, it prompts for user selection.
  `;

  public static examples = [
    '$ sf hardis:project:generate:bypass',  
    '$ sf hardis:project:generate:bypass --global',  
    '$ sf hardis:project:generate:bypass --sObjects Account,Contact,Opportunity',  
    '$ sf hardis:project:generate:bypass --automations Flow,Trigger,VR',  
    '$ sf hardis:project:generate:bypass --sObjects Account,Opportunity --automations Flow,Trigger',  
    '$ sf hardis:project:generate:bypass --skip-credits',
  ];


  public async querySObjects(connection: Connection) {
    const sObjectsQuery = `
    Select Id, Label, DeveloperName, DurableId,  IsTriggerable, IsCustomizable, IsApexTriggerable, NamespacePrefix, PublisherId FROM EntityDefinition  WHERE IsTriggerable = true AND IsCustomizable = true and IsCustomSetting = false ORDER BY DeveloperName`;

    const sObjectResults = await soqlQuery(sObjectsQuery, connection);
    uxLog(this, `Found ${sObjectResults.records.length} sObjects.`);
    return sObjectResults;
  }

  public async getFilteredSObjects(connection: Connection):Promise<{[key:string]:string}>{
    const sObjectResults = await this.querySObjects(connection);
    const sObjectsDict: {[key:string]:string} = {};

    sObjectResults.records.forEach((record) => {
      if (!record.DeveloperName.endsWith('__Share') && !record.DeveloperName.endsWith('__ChangeEvent')) {
        sObjectsDict[record.DeveloperName] = record.Label;
      }
    });

    return sObjectsDict;
  }

  public generateCustomPermissionXML(sObject: string, automation: string, skipCredits: boolean = false): string {
    const creditsText = skipCredits ? '' : ` ${CREDITS_TEXT}`;
    return `<?xml version="1.0" encoding="UTF-8"?>
  <CustomPermission xmlns="http://soap.sforce.com/2006/04/metadata">
    <isLicensed>false</isLicensed>
    <label>Bypass ${automation}s for ${sObject}</label>
    <description>If assigned (through a Permission Set), this Custom Permission will disable the execution of ${automation}s defined on the ${sObject} sObject.${creditsText}</description>
  </CustomPermission>`;
  }

  public generatePermissionSetXML(sObject: string, automation: string, skipCredits: boolean = false): string {
    const creditsText = skipCredits ? '' : ` ${CREDITS_TEXT}`;
    return `<?xml version="1.0" encoding="UTF-8"?>
  <PermissionSet xmlns="http://soap.sforce.com/2006/04/metadata">
    <customPermissions>
        <enabled>true</enabled>
        <name>Bypass${sObject}${automation}s</name>
    </customPermissions>
    <hasActivationRequired>false</hasActivationRequired>
    <label>Bypass ${automation}s for ${sObject}</label>
    <description>If assigned, this Permission Set will disable the execution of ${automation}s defined on the ${sObject} sObject.${creditsText}</description>
  </PermissionSet>`;
  }


  private generateXMLFiles(sObject: string, automation: string, skipCredits: boolean) {
    const customPermissionFile = path.join(`force-app/main/default/customPermissions/Bypass${sObject}${automation}s.customPermission-meta.xml`);
    const permissionSetFile = path.join(`force-app/main/default/permissionsets/Bypass${sObject}${automation}s.permissionset-meta.xml`);
  
    fs.writeFileSync(customPermissionFile, this.generateCustomPermissionXML(sObject, automation, skipCredits), 'utf-8');
    fs.writeFileSync(permissionSetFile, this.generatePermissionSetXML(sObject, automation, skipCredits), 'utf-8');

    uxLog(this, `Created: ${path.basename(customPermissionFile)} for ${sObject}`);
    uxLog(this, `Created: ${path.basename(permissionSetFile)} for ${sObject}`);
  }
  
  generateFiles(targetSObjects: { [key: string]: string }, targetAutomations: string[], skipCredits: boolean): void {
    Object.entries(targetSObjects).map(([developerName]) => {
      targetAutomations.forEach(automation => {
        this.generateXMLFiles(developerName, automation, skipCredits);
      });
    });
  }

  public async run(): Promise<AnyJson> {
    const { flags } = await this.parse(HardisProjectGenerateBypass);
    const connection = flags['target-org'].getConnection();

    const generateGlobalBypasses = flags['global'];
    const sObjectsFromFlag = flags['sObjects'] ? flags['sObjects'].split(',').map(sObject => sObject.trim().replace(/__c$/, '')).map(s => s.trim()) : undefined;
    const automationsFromFlag = flags['automations'] ? flags['automations'].split(',').map(s => s.trim()).filter(s => ALLOWED_AUTOMATIONS.includes(s)) : undefined;
    const availableSObjects = await this.getFilteredSObjects(connection);
    const skipCredits = flags['skipCredits'];

    // Generate global bypasses if they are requested.
    if(generateGlobalBypasses){
      this.generateFiles({ 'All': 'All' }, ALLOWED_AUTOMATIONS, skipCredits);
    }

    let targetSObjects: {[key:string]:string} = sObjectsFromFlag ? Object.fromEntries(
      Object.entries(availableSObjects).filter(([key]) => sObjectsFromFlag.includes(key))
    ) : {};
    let targetAutomations: string[] = automationsFromFlag || [];

    const possiblePrompts:any = [];

    if(!sObjectsFromFlag || Object.keys(targetSObjects).length === 0){
      
      uxLog(this, c.yellow('[sfdx-hardis] WARNING : No matching sObjects found. Please check your input or select from the prompt.'));

      possiblePrompts.push({
        type: 'multiselect',
        name: 'sobjects',
        message: 'Please select the sObjects for which you want to generate the bypass(es)',
        choices: Object.entries(availableSObjects).map(([developerName, label])  => {
          return {title: label, value: developerName}
        })
      })
    }
    if(!automationsFromFlag){
      possiblePrompts.push({
        type: 'multiselect',
        name: 'automations',
        message: 'Please which automations you wish to bypass.',
        choices: [
          {title: "Flows", value: "Flow"},
          {title: "Triggers", value: "Trigger"},
          {title: "Validation Rules", value: "VR"}
        ]
      })
    }
    if(possiblePrompts.length > 0){
      const promptSelection = await prompts(possiblePrompts);
      if(!sObjectsFromFlag){
        if(promptSelection?.sobjects.length === 0){
          throw new SfError(
            c.red(
              `[sfdx-hardis] ERROR: You must select or provide (--sObjects) at least one sObject available on your org.`
            )
          );
        }
      targetSObjects =  Object.fromEntries(
        Object.entries(availableSObjects).filter(([key]) => promptSelection.sobjects.includes(key))
      );
      }
      if(!automationsFromFlag){
        if(promptSelection?.automations.length === 0){
          throw new SfError(
            c.red(
              `[sfdx-hardis] ERROR: You must select or provide (--automations) at least one automation to bypass.`
            )
          );
        }
        targetAutomations = promptSelection.automations;
      }
    }

    if(Object.keys(targetSObjects).length > 0 && targetAutomations.length > 0){
      this.generateFiles(targetSObjects, targetAutomations, skipCredits);
    }

    return {
      outputString: 'Generated bypass custom permissions and permission sets',
    };
  }
}
