import c from 'chalk';
import { UtilsAi } from "../aiProvider/utils.js";
import { uxLog } from "../utils/index.js";
import { PromptTemplate } from '../aiProvider/promptTemplates.js';
import { AiProvider } from '../aiProvider/index.js';
import { XMLParser } from 'fast-xml-parser';
import fs from 'fs-extra';
import path from 'path';
import { getMetaHideLines } from './docUtils.js';
import { CONSTANTS } from '../../config/index.js';

export abstract class DocBuilderRoot {
  public docType: string;
  public promptKey: PromptTemplate;
  public placeholder: string;
  public xmlRootKey: string;
  public docsSection: string;

  public metadataName: string;
  public metadataXml: string = "";
  public outputFile: string;
  public additionalVariables: any;

  public markdownDoc: string;
  public parsedXmlObject: any;

  constructor(metadataName: string, metadataXml: string, outputFile: string, additionalVariables: any = {}) {
    this.metadataName = metadataName;
    this.metadataXml = metadataXml;
    this.outputFile = outputFile;
    this.additionalVariables = additionalVariables;
  }

  // This method must be overridden
  public async buildInitialMarkdownLines(): Promise<string[]> {
    return [];
  }

  public async generateMarkdownFileFromXml() {
    if (this.xmlRootKey) {
      this.parsedXmlObject = new XMLParser().parse(this.metadataXml)?.[this.xmlRootKey] || {};
    }
    // Main lines generated by overridden method
    const mdLines = await this.buildInitialMarkdownLines();
    // Footer
    mdLines.push("");
    mdLines.push(`_Documentation generated with [sfdx-hardis](${CONSTANTS.DOC_URL_ROOT})_`);

    this.markdownDoc = mdLines.join("\n") + "\n";
    this.markdownDoc = await this.completeDocWithAiDescription();

    await fs.ensureDir(path.dirname(this.outputFile));
    await fs.writeFile(this.outputFile, getMetaHideLines() + this.markdownDoc);
    uxLog(this, c.green(`Successfully generated ${this.metadataName} documentation into ${this.outputFile}`));
    const jsonTree = await this.generateJsonTree();
    if (jsonTree) {
      const jsonFile = `./docs/json/${this.docsSection}-${this.metadataName}.json`;
      await fs.ensureDir(path.dirname(jsonFile));
      await fs.writeFile(jsonFile, JSON.stringify(jsonTree, null, 2));
      uxLog(this, c.green(`Successfully generated ${this.metadataName} JSON into ${jsonFile}`));
    }
    return this.outputFile;
  }

  public async completeDocWithAiDescription(): Promise<string> {
    const xmlStripped = await this.stripXmlForAi();
    const aiCache = await UtilsAi.findAiCache(this.promptKey, [xmlStripped], this.metadataName);

    if (aiCache.success === true) {
      uxLog(this, c.grey(`Used AI cache for ${this.docType.toLowerCase()} description (set IGNORE_AI_CACHE=true to force call to AI)`));
      const replaceText = `## AI-Generated Description\n\n<!-- Cache file: ${aiCache.aiCacheDirFile} -->\n\n${aiCache.cacheText || ""}`;
      this.markdownDoc = this.markdownDoc.replace(this.placeholder, replaceText);
      return this.markdownDoc;
    }

    if (AiProvider.isAiAvailable()) {
      const defaultVariables = { [`${this.docType.toUpperCase()}_NAME`]: this.metadataName, [`${this.docType.toUpperCase()}_XML`]: xmlStripped };
      const variables = Object.assign(defaultVariables, this.additionalVariables);
      const prompt = AiProvider.buildPrompt(this.promptKey, variables);

      const aiResponse = await AiProvider.promptAi(prompt, this.promptKey);
      if (aiResponse?.success) {
        let responseText = aiResponse.promptResponse || "No AI description available";
        if (responseText.startsWith("##")) {
          responseText = responseText.split("\n").slice(1).join("\n");
        }
        await UtilsAi.writeAiCache(this.promptKey, [xmlStripped], this.metadataName, responseText);
        const replaceText = `## AI-Generated Description\n\n<!-- Cache file: ${aiCache.aiCacheDirFile} -->\n\n${responseText}`;
        this.markdownDoc = this.markdownDoc.replace(this.placeholder, replaceText);
        return this.markdownDoc;
      }
    }

    return this.markdownDoc;
  }

  // Override this method if you need to make a smaller XML to fit in the number of prompt tokens
  public async stripXmlForAi(): Promise<string> {
    return this.metadataXml;
  }

  // Override this method if you need to generate a JSON tree for the doc
  public async generateJsonTree(): Promise<any> {
    return null;
  }

}